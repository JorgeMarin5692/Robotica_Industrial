# -*- coding: utf-8 -*-
"""cinematica inv-direct.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DMUY4OwlwX3rFa-4xcwDKS5D9bfk0bg9

Autores

* Jorge Andres Marin Alvarez
* Mateo Mendoza Vera
* Camilo Avilan Payares
"""

!pip install roboticstoolbox-python

"""Primero, definimos un robot de 5 grados de libertad (DoF) utilizando la herramienta Robotic Toolbox (RTB) en Python. Este robot está definido con parámetros de Denavit-Hartenberg (DH) personalizados. Los parámetros DH son valores que describen la geometría y la cinemática del robot. En este caso, se definen utilizando la clase RevoluteDH de RTB. Cada articulación del robot se define con su propio conjunto de parámetros DH, que incluyen la longitud del enlace (d), la longitud del offset (a), el ángulo de offset (alpha), y el ángulo de giro (offset) si es necesario.

Luego, se calcula la cinemática directa del robot (la posición y orientación del extremo del robot) para una configuración de articulaciones inicial q, utilizando el método fkine. Esto se realiza mediante la matriz de transformación homogénea T.

Después, definimos una posición deseada para el extremo del robot (T_des). Queremos encontrar los ángulos de articulación necesarios para que el extremo del robot alcance esta posición deseada. Para ello, utilizamos la cinemática inversa, que se calcula utilizando el método ikine_LM (método de Levenberg-Marquardt) proporcionado por RTB. Esto devuelve una solución para los ángulos de articulación que satisfacen la posición y orientación deseadas del extremo del robot.

Finalmente, imprimimos los ángulos de articulación obtenidos (sol.q) que logran la posición deseada del extremo del robot.
"""

import roboticstoolbox as rtb
from spatialmath import SE3
import numpy as np

# Definimos el robot utilizando los nuevos parámetros DH
customized_robot_5dof = rtb.DHRobot(
    [
        rtb.RevoluteDH(d=40.38, a=0, alpha=-np.pi/2),
        rtb.RevoluteDH(offset= np.pi/2, d=0, a=120, alpha=0),
        rtb.RevoluteDH(offset=0, d=115, a=0, alpha= np.pi/2),
        rtb.RevoluteDH(offset=-np.pi/2, d=31.76, a=0, alpha=np.pi/2),
        rtb.RevoluteDH(offset=0, d=-0, a=0, alpha=0)
    ], name="5DoF Robot")
customized_robot_5dof

print(customized_robot_5dof)
# Configuración de las articulaciones (en radianes)
q = [0,0,0,0,0]

# Cinemática directa
T = customized_robot_5dof.fkine(q)
print("Cinemática Directa:")
print(T)

# Definimos una posición objetivo para el extremo del robot
T_des = SE3(1500, 1000, -1000)  # posición deseada

# Cinemática inversa
sol = customized_robot_5dof.ikine_LM(T_des)
print("\nCinemática Inversa:")
print(sol)

# Mostrar los ángulos articulares solucionados
print("\nÁngulos articulares obtenidos para alcanzar la posición deseada:")
print(sol.q)

"""La función forward_kinematics calcula la cinemática directa de un manipulador de cinco grados de libertad en el espacio tridimensional. Toma como entrada los valores de los ángulos de articulación (theta1, theta2, theta3, theta4, theta5) y las longitudes de los eslabones (l1, l2, l3, l4, l5).

La coordenada x se calcula sumando las proyecciones de los eslabones a lo largo del eje x, donde cada proyección está ponderada por el coseno del ángulo correspondiente. La coordenada y se calcula de manera similar a la coordenada x, pero utilizando las proyecciones a lo largo del eje y y los senos de los ángulos. La coordenada z se calcula sumando las longitudes de los eslabones a lo largo del eje z, teniendo en cuenta las proyecciones verticales y los senos de los ángulos.

Finalmente, la función devuelve las coordenadas x, y, y z que representan la posición del extremo del manipulador en el espacio tridimensional.



$$
x = l_1 \cos(\theta_1) + l_2 \cos(\theta_1 + \theta_2) + l_3 \cos(\theta_1 + \theta_2 + \theta_3) + l_4 \cos(\theta_1 + \theta_2 + \theta_3 + \theta_4) + l_5 \cos(\theta_1 + \theta_2 + \theta_3 + \theta_4 + \theta_5)
$$

$$
y = l_1 \sin(\theta_1) + l_2 \sin(\theta_1 + \theta_2) + l_3 \sin(\theta_1 + \theta_2 + \theta_3) + l_4 \sin(\theta_1 + \theta_2 + \theta_3 + \theta_4) + l_5 \sin(\theta_1 + \theta_2 + \theta_3 + \theta_4 + \theta_5)
$$

$$
z = l_1 + l_2 \sin(\theta_2) + l_3 \sin(\theta_2 + \theta_3) + l_4 \sin(\theta_2 + \theta_3 + \theta_4) + l_5 \sin(\theta_2 + \theta_3 + \theta_4 + \theta_5)
$$


"""

import numpy as np

def forward_kinematics(theta1, theta2, theta3, theta4, theta5, l1, l2, l3, l4, l5):
    x = l1 * np.cos(theta1) + l2 * np.cos(theta1 + theta2) + l3 * np.cos(theta1 + theta2 + theta3) + l4 * np.cos(theta1 + theta2 + theta3 + theta4) + l5 * np.cos(theta1 + theta2 + theta3 + theta4 + theta5)
    y = l1 * np.sin(theta1) + l2 * np.sin(theta1 + theta2) + l3 * np.sin(theta1 + theta2 + theta3) + l4 * np.sin(theta1 + theta2 + theta3 + theta4) + l5 * np.sin(theta1 + theta2 + theta3 + theta4 + theta5)
    z = l1 + l2 * np.sin(theta2) + l3 * np.sin(theta2 + theta3) + l4 * np.sin(theta2 + theta3 + theta4) + l5 * np.sin(theta2 + theta3 + theta4 + theta5)
    return x, y, z

"""
La matriz que te proporcioné representa un conjunto de valores \( j_{ij} \), donde \( i \) y \( j \) son índices que indican la fila y la columna respectivamente.

Cada elemento de la matriz está compuesto por una expresión que depende de \( l_1, l_2, l_3, l_4, l_5 \) (longitudes) y \( \theta_1, \theta_2, \theta_3, \theta_4, \theta_5 \) (ángulos), según las siguientes fórmulas trigonométricas:

- Los elementos de la primera fila (\( j_{11}, j_{12}, j_{13}, j_{14}, j_{15} \)) representan combinaciones de longitudes y senos de los ángulos.
- Los elementos de la segunda fila (\( j_{21}, j_{22}, j_{23}, j_{24}, j_{25} \)) representan combinaciones de longitudes y cosenos de los ángulos.
- Los elementos de la tercera fila (\( j_{31}, j_{32}, j_{33}, j_{34}, j_{35} \)) tienen una forma similar a los de la segunda fila, pero la primera columna es cero.

Estos valores son importantes en contextos como cinemática o dinámica de manipuladores robóticos, donde representan las derivadas de las coordenadas de posición respecto a los ángulos de las articulaciones (Jacobiano).


\[
\begin{bmatrix}
    j_{11} & j_{12} & j_{13} & j_{14} & j_{15} \\
    j_{21} & j_{22} & j_{23} & j_{24} & j_{25} \\
    j_{31} & j_{32} & j_{33} & j_{34} & j_{35}
\end{bmatrix}
=
\]
\[
\begin{bmatrix}
    -l_1 \sin(\theta_1) - l_2 \sin(\theta_1 + \theta_2) - l_3 \sin(\theta_1 + \theta_2 + \theta_3) - l_4 \sin(\theta_1 + \theta_2 + \theta_3 + \theta_4) - l_5 \sin(\theta_1 + \theta_2 + \theta_3 + \theta_4 + \theta_5) & -l_2 \sin(\theta_1 + \theta_2) - l_3 \sin(\theta_1 + \theta_2 + \theta_3) - l_4 \sin(\theta_1 + \theta_2 + \theta_3 + \theta_4) - l_5 \sin(\theta_1 + \theta_2 + \theta_3 + \theta_4 + \theta_5) & -l_3 \sin(\theta_1 + \theta_2 + \theta_3) - l_4 \sin(\theta_1 + \theta_2 + \theta_3 + \theta_4) - l_5 \sin(\theta_1 + \theta_2 + \theta_3 + \theta_4 + \theta_5) & -l_4 \sin(\theta_1 + \theta_2 + \theta_3 + \theta_4) - l_5 \sin(\theta_1 + \theta_2 + \theta_3 + \theta_4 + \theta_5) & -l_5 \sin(\theta_1 + \theta_2 + \theta_3 + \theta_4 + \theta_5) \\
    l_1 \cos(\theta_1) + l_2 \cos(\theta_1 + \theta_2) + l_3 \cos(\theta_1 + \theta_2 + \theta_3) + l_4 \cos(\theta_1 + \theta_2 + \theta_3 + \theta_4) + l_5 \cos(\theta_1 + \theta_2 + \theta_3 + \theta_4 + \theta_5) & l_2 \cos(\theta_1 + \theta_2) + l_3 \cos(\theta_1 + \theta_2 + \theta_3) + l_4 \cos(\theta_1 + \theta_2 + \theta_3 + \theta_4) + l_5 \cos(\theta_1 + \theta_2 + \theta_3 + \theta_4 + \theta_5) & l_3 \cos(\theta_1 + \theta_2 + \theta_3) + l_4 \cos(\theta_1 + \theta_2 + \theta_3 + \theta_4) + l_5 \cos(\theta_1 + \theta_2 + \theta_3 + \theta_4 + \theta_5) & l_4 \cos(\theta_1 + \theta_2 + \theta_3 + \theta_4) + l_5 \cos(\theta_1 + \theta_2 + \theta_3 + \theta_4 + \theta_5) & l_5 \cos(\theta_1 + \theta_2 + \theta_3 + \theta_4 + \theta_5) \\
    0 & l_2 \cos(\theta_2) + l_3 \cos(\theta_2 + \theta_3) + l_4 \cos(\theta_2 + \theta_3 + \theta_4) + l_5 \cos(\theta_2 + \theta_3 + \theta_4 + \theta_5) & l_3 \cos(\theta_2 + \theta_3) + l_4 \cos(\theta_2 + \theta_3 + \theta_4) + l_5 \cos(\theta_2 + \theta_3 + \theta_4 + \theta_5) & l_4 \cos(\theta_2 + \theta_3 + \theta_4) + l_5 \cos(\theta_2 + \theta_3 + \theta_4 + \theta_5) & l_5 \cos(\theta_2 + \theta_3 + \theta_4 + \theta_5)
\end{bmatrix}
\]


"""

def jacobian(theta1, theta2, theta3, theta4, theta5, l1, l2, l3, l4, l5):
    j11 = -l1 * np.sin(theta1) - l2 * np.sin(theta1 + theta2) - l3 * np.sin(theta1 + theta2 + theta3) - l4 * np.sin(theta1 + theta2 + theta3 + theta4) - l5 * np.sin(theta1 + theta2 + theta3 + theta4 + theta5)
    j12 = -l2 * np.sin(theta1 + theta2) - l3 * np.sin(theta1 + theta2 + theta3) - l4 * np.sin(theta1 + theta2 + theta3 + theta4) - l5 * np.sin(theta1 + theta2 + theta3 + theta4 + theta5)
    j13 = -l3 * np.sin(theta1 + theta2 + theta3) - l4 * np.sin(theta1 + theta2 + theta3 + theta4) - l5 * np.sin(theta1 + theta2 + theta3 + theta4 + theta5)
    j14 = -l4 * np.sin(theta1 + theta2 + theta3 + theta4) - l5 * np.sin(theta1 + theta2 + theta3 + theta4 + theta5)
    j15 = -l5 * np.sin(theta1 + theta2 + theta3 + theta4 + theta5)

    j21 = l1 * np.cos(theta1) + l2 * np.cos(theta1 + theta2) + l3 * np.cos(theta1 + theta2 + theta3) + l4 * np.cos(theta1 + theta2 + theta3 + theta4) + l5 * np.cos(theta1 + theta2 + theta3 + theta4 + theta5)
    j22 = l2 * np.cos(theta1 + theta2) + l3 * np.cos(theta1 + theta2 + theta3) + l4 * np.cos(theta1 + theta2 + theta3 + theta4) + l5 * np.cos(theta1 + theta2 + theta3 + theta4 + theta5)
    j23 = l3 * np.cos(theta1 + theta2 + theta3) + l4 * np.cos(theta1 + theta2 + theta3 + theta4) + l5 * np.cos(theta1 + theta2 + theta3 + theta4 + theta5)
    j24 = l4 * np.cos(theta1 + theta2 + theta3 + theta4) + l5 * np.cos(theta1 + theta2 + theta3 + theta4 + theta5)
    j25 = l5 * np.cos(theta1 + theta2 + theta3 + theta4 + theta5)

    j31 = 0
    j32 = l2 * np.cos(theta2) + l3 * np.cos(theta2 + theta3) + l4 * np.cos(theta2 + theta3 + theta4) + l5 * np.cos(theta2 + theta3 + theta4 + theta5)
    j33 = l3 * np.cos(theta2 + theta3) + l4 * np.cos(theta2 + theta3 + theta4) + l5 * np.cos(theta2 + theta3 + theta4 + theta5)
    j34 = l4 * np.cos(theta2 + theta3 + theta4) + l5 * np.cos(theta2 + theta3 + theta4 + theta5)
    j35 = l5 * np.cos(theta2 + theta3 + theta4 + theta5)

    return np.array([[j11, j12, j13, j14, j15], [j21, j22, j23, j24, j25], [j31, j32, j33, j34, j35]])

"""
El código proporciona una función llamada `inverse_kinematics` que se utiliza para calcular las coordenadas articulares necesarias para alcanzar una posición objetivo en un sistema robótico de múltiples grados de libertad. La función toma los siguientes parámetros:

- `target`: La posición objetivo que se desea alcanzar.
- `theta`: Un arreglo que contiene las coordenadas articulares actuales del sistema.
- `l1, l2, l3, l4, l5`: Las longitudes de los eslabones del sistema.
- `epsilon`: La precisión deseada para la convergencia del algoritmo. Es decir, la diferencia mínima entre la posición objetivo y la posición actual.
- `max_iterations`: El número máximo de iteraciones que el algoritmo ejecutará antes de detenerse, independientemente de si se alcanza la precisión deseada.

Dentro de la función, se utiliza un bucle `for` para iterar un máximo de `max_iterations` veces. En cada iteración, se calcula la posición actual del sistema utilizando la función `forward_kinematics` y se calcula el error entre la posición objetivo y la posición actual.

Si el error es menor que `epsilon`, lo que significa que la posición actual está lo suficientemente cerca de la posición objetivo, el bucle se interrumpe y se devuelve el valor actual de `theta`.

Si el error es mayor que `epsilon`, se calcula el jacobiano del sistema utilizando la función `jacobian`. El jacobiano es una matriz que relaciona las velocidades de las articulaciones con las velocidades del extremo del robot.

Se utiliza la pseudo-inversa del jacobiano para calcular el cambio necesario en las coordenadas articulares (`delta_theta`) para reducir el error. Este cambio se agrega a las coordenadas articulares actuales `theta`.

Una vez que el bucle ha terminado, se devuelve el valor final de `theta`, que representa las coordenadas articulares necesarias para alcanzar la posición objetivo o el estado más cercano posible a ella.
"""

import numpy as np

def inverse_kinematics(target, theta, l1, l2, l3, l4, l5, epsilon=1e-10, max_iterations=1000):
    for i in range(max_iterations):
        current = forward_kinematics(theta[0], theta[1], theta[2], theta[3], theta[4], l1, l2, l3, l4, l5)
        error = target - current
        if np.linalg.norm(error) < epsilon:
            break
        J = jacobian(theta[0], theta[1], theta[2], theta[3], theta[4], l1, l2, l3, l4, l5)
        delta_theta = np.linalg.pinv(J) @ error  # Use pseudo-inverse to handle non-square Jacobian
        theta += delta_theta
    return theta

# Test the function
target_position = np.array([50, 15, 30])
initial_angles = np.array([0.1, 0.1, 0.1, 0.1, 0.1])  # Debes proporcionar 5 ángulos iniciales
link_lengths = [40.38, 120, 115, 31.76, 0]  # Debes proporcionar 5 longitudes de enlace
angles = inverse_kinematics(target_position, initial_angles, *link_lengths)
print(f"Computed angles: {angles}")

forward_kinematics(  0.49163577,-14.0131249,22.18387752,16.94371566 ,0.1,40.38, 120, 115, 31.76, 0 )